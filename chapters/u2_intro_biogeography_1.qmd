---
title: "Introducci√≥n a la biogeograf√≠a filogen√©tica con el modelo DEC"
format: html
execute:
  echo: true   # Muestra el c√≥digo
  warning: false  # Oculta advertencias
  fig-width: 12   # Ancho del gr√°fico
  fig-height: 8   # Altura del gr√°fico
---

## **Introducci√≥n**

Muchos procesos evolutivos fundamentales, como la adaptaci√≥n, la especiaci√≥n y la extinci√≥n, ocurren en un contexto espacial. Cuando no es posible observar directamente los aspectos hist√≥ricos de este contexto espacial, como sucede en la mayor√≠a de los casos, se pueden aplicar m√©todos de inferencia biogeogr√°fica para estimar los rangos ancestrales de las especies.

Estos m√©todos combinan informaci√≥n filogen√©tica, molecular y geogr√°fica para modelar la distribuci√≥n de especies como el resultado de procesos biogeogr√°ficos. Sin embargo, modelar estos procesos requiere de un an√°lisis detallado, considerando aspectos como:

-   C√≥mo se heredan los rangos tras eventos de especiaci√≥n.

-   C√≥mo los eventos geol√≥gicos pueden influir en las tasas de dispersi√≥n.

-   Qu√© factores afectan las tasas de dispersi√≥n y extirpaci√≥n (extinci√≥n local).

Uno de los principales desaf√≠os t√©cnicos en la modelizaci√≥n de la evoluci√≥n de rangos geogr√°ficos es traducir estos procesos naturales en procesos estoc√°sticos que sean manejables en un contexto de inferencia. Este tutorial proporciona una introducci√≥n a algunos de estos modelos y describe c√≥mo realizar una inferencia bayesiana de la biogeograf√≠a hist√≥rica utilizando el modelo de [**Dispersi√≥n-Extinci√≥n-Cladog√©nesis (DEC)** en RevBayes](https://revbayes.github.io/tutorials/biogeo/biogeo_intro.html).

## **Descripci√≥n del Modelo de Dispersi√≥n-Extinci√≥n-Cladog√©nesis (DEC)**

El modelo **DEC** modela la evoluci√≥n de rangos como un proceso discreto (Ree et al. 2005; Ree y Smith 2008). Este modelo incluye tres componentes clave:

1.  **Caracteres de Rango:** Representaci√≥n de la distribuci√≥n de una especie como un conjunto de √°reas discretas.

2.  **Evoluci√≥n Anagen√©tica del Rango:** Cambios en el rango geogr√°fico dentro de una l√≠nea evolutiva antes de un evento de especiaci√≥n.

3.  **Evoluci√≥n Cladogen√©tica del Rango:** Cambios en la distribuci√≥n de la especie durante eventos de especiaci√≥n.

A continuaci√≥n, se presentan los posibles eventos modelados en DEC:

![](https://ixchelgzlzr.github.io/filo_bayes_UNAM/docs/biogeo/figures/fig_range_evol_events.png){fig-align="center" width="600"}

### **Eventos Anagen√©ticos (cambios dentro de una misma l√≠nea evolutiva):**

-   **(a) Dispersi√≥n:** Una especie expande su rango al colonizar una nueva √°rea.

-   **(b) Extirpaci√≥n (o extinci√≥n local):** Una especie pierde una de sus √°reas previamente habitadas.

### **Eventos Cladogen√©ticos (cambios en la distribuci√≥n durante la especiaci√≥n):**

-   **(c) Simpatr√≠a restringida:** Si el ancestro estaba restringido a un solo territorio, ambas especies descendientes heredan esa misma √°rea.

-   **(d) Simpatr√≠a parcial:** Si el ancestro ten√≠a un rango amplio, una de las especies descendientes hereda el rango ancestral, mientras que la otra se restringe a una sola de sus √°reas.

-   **(e) Alopatr√≠a (o vicarianza):** Si el ancestro ten√≠a un rango amplio, cada especie descendiente hereda un subconjunto diferente de ese rango.

-   **(f) Simpatr√≠a generalizada:** Ambas especies descendientes heredan el mismo rango amplio del ancestro.

-   **(g) Dispersi√≥n por salto (o especiaci√≥n fundadora):** Una especie descendiente hereda el rango ancestral mientras que la otra coloniza una nueva √°rea previamente no ocupada.

Estos eventos permiten modelar de manera realista c√≥mo evolucionan las distribuciones geogr√°ficas a lo largo del tiempo en un contexto filogen√©tico.

## **Caracteres de Rango Discretos en el Modelo DEC**

El modelo **DEC** interpreta los rangos de los taxones como **datos de presencia-ausencia**. Es decir, representa en qu√© √°reas una especie est√° presente o ausente a lo largo de m√∫ltiples regiones discretas.

Por ejemplo, supongamos que trabajamos con tres √°reas geogr√°ficas: **A, B y C**.\
Si una especie se encuentra en las √°reas **A y C**, su rango se puede representar como **AC**. Este rango se codifica mediante un **vector binario de longitud 3**, donde:

-   **1** indica presencia en un √°rea.

-   **0** indica ausencia en un √°rea.

Para el rango **AC**, la representaci√≥n en bits ser√≠a `101`. Esta notaci√≥n tambi√©n puede transformarse en un n√∫mero entero utilizando su representaci√≥n binaria:

-   `101` en binario equivale a **5** en decimal.

### **Ejemplo de Representaciones Discretas de Rangos**

A continuaci√≥n, se muestra c√≥mo se representan distintos rangos para un an√°lisis con tres √°reas (**A, B y C**):

| **Rango** | **Bits** | **N√∫mero de √°reas** | **Valor entero** |
|-----------|----------|---------------------|------------------|
| (vac√≠o)   | `000`    | 0                   | 0                |
| A         | `100`    | 1                   | 1                |
| B         | `010`    | 1                   | 2                |
| C         | `001`    | 1                   | 3                |
| AB        | `110`    | 2                   | 4                |
| AC        | `101`    | 2                   | 5                |
| BC        | `011`    | 2                   | 6                |
| ABC       | `111`    | 3                   | 7                |

### **Evoluci√≥n Anagen√©tica del Rango en el Modelo DEC**

La **anag√©nesis** se refiere a la evoluci√≥n de los rangos geogr√°ficos que ocurre **entre eventos de especiaci√≥n**, es decir, dentro de una misma l√≠nea evolutiva.

Existen dos tipos principales de eventos anagen√©ticos:

1.  **Dispersi√≥n (Figura 1a):** Ocurre cuando una especie coloniza una nueva √°rea.

2.  **Extirpaci√≥n o extinci√≥n local (Figura 1b):** Ocurre cuando una especie pierde una de sus √°reas previamente ocupadas.

Dado que el modelo DEC usa rangos discretos, la anag√©nesis se modela utilizando una **cadena de Markov de tiempo continuo (CTMC)**. En este modelo:

-   La probabilidad de que un rango cambie de estado (de $i$ a $j$) en un tiempo $t$ se calcula mediante **exponenciaci√≥n de matrices**, seg√∫n la ecuaci√≥n:

    $$ P_{ij}(t) = [exp(Qt)]_{ij} $$

donde:

-   $Q$ es la **matriz de tasas instant√°neas**, que define las tasas de cambio entre todos los pares de estados.

-   $P$ es la **matriz de probabilidad de transici√≥n**.

-   $i$ y $j$ representan diferentes rangos, los cuales se codifican como conjuntos de √°reas ocupadas por una especie.

-   La probabilidad **integra todas las posibles trayectorias** de cambios de estado en el tiempo $t$.

## **Definici√≥n de la Matriz de Tasas (Q)**

Podemos definir la matriz $Q$ de anag√©nesis en t√©rminos de tasas de **extinci√≥n local (**$e$) y **dispersi√≥n (**$d$). Para tres √°reas geogr√°ficas ($A$, $B$, $C$), la matriz de tasas de evoluci√≥n anagen√©tica tiene la siguiente estructura:

$$
Q =
\begin{array}{c|cccccccc}
   & \emptyset & A & B & C & AB & AC & BC & ABC \\
\hline
\emptyset & - & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
A & e_A & - & 0 & 0 & d_{AB} & d_{AC} & 0 & 0 \\
B & e_B& 0 & - & 0 & d_{BA} & 0 & d_{BC} & 0 \\
C & e_C & 0 & 0 & - & 0 & d_{CA} & d_{CB} & 0 \\
AB & 0 & e_B & e_A & 0 & - & 0 & 0 & d_{AC} + d_{BC} \\
AC & 0 & e_C & 0 & e_A & 0 & - & 0 & d_{AB} + d_{CB} \\
BC & 0 & 0 & e_C & e_B & 0 & 0 & - & d_{BA} + d_{CA} \\
ABC & 0 & 0 & 0 & 0 & e_C & e_B & e_A & - \\
\end{array}
$$

donde:

-   $e = (eA, eB, eC)$ representan las tasas de extinci√≥n local por √°rea.

-   $d = (dAB, dAC, dBC, dBA, dCA, dCB)$ representan las tasas de dispersi√≥n entre pares de √°reas.

-   **El rango vac√≠o (**$‚àÖ$) es un estado absorbente: cualquier linaje que pierda todas sus √°reas se mantiene en ese estado de manera permanente.

### üß† Construcci√≥n de una matriz de tasa DEC en RevBayes.

Ejecutar en `rb` los siguientes comandos:

Definir el n√∫mero de √°reas:

``` r
n_areas <- 3
```

## Anagenesis: Matriz de tasas $Q$

Matriz de dispersi√≥n:

``` r
for (i in 1:n_areas) {
    for (j in 1:n_areas) {
        dr[i][j] <- 1.0
    }
}
```

**¬øQu√© est√° haciendo este c√≥digo?**

1.  Se define una **matriz cuadrada** de tama√±o $3x3$ (porque hay 3 √°reas).

2.  Se llena con $1.0$ en todas las posiciones $dr[i][j]$, lo que significa **que todas las √°reas est√°n conectadas por igual**.

3.  Se asume que la dispersi√≥n **no depende de la direcci√≥n** (`A ‚Üí B` es igual que `B ‚Üí A`).

**Matriz de dispersi√≥n:**

``` r
for (i in 1:n_areas) {
    for (j in 1:n_areas) {
        dr[i][j] <- 1.0
    }
}
```

**¬øQu√© est√° haciendo este c√≥digo?**

1.  Se define una **matriz cuadrada** de tama√±o $3x3$ (porque hay 3 √°reas).

2.  Se llena con $1.0$ en todas las posiciones $dr[i][j]$, lo que significa **que todas las √°reas est√°n conectadas por igual**.

3.  Se asume que la dispersi√≥n **no depende de la direcci√≥n** (`A ‚Üí B` es igual que `B ‚Üí A`).

**Matriz de extirpaci√≥n:**

``` r
for (i in 1:n_areas) {
    for (j in 1:n_areas) {
        er[i][j] <- 0.0
    }
    er[i][i] <- 1.0
}
```

**¬øQu√© est√° haciendo este c√≥digo?**

1.  Se define una **matriz cuadrada** de tama√±o $3x3$ (porque hay 3 √°reas).

2.  Inicializa toda la matriz $er$ con 0.0 **(asumiendo que no hay extirpaci√≥n entre diferentes √°reas)**.

3.  Pone $1.0$ en la diagonal de la matriz $(A ‚Üí ‚àÖ, B ‚Üí ‚àÖ, C ‚Üí ‚àÖ)$.

4.  Esto significa que cada √°rea tiene una **tasa de extirpaci√≥n de 1.0** por s√≠ misma.

5.  **No hay extirpaci√≥n cruzada** ($A ‚Üí B$ no ocurre, solo $A ‚Üí ‚àÖ$).

**Crear la matriz Q_DEC:**

Con las matrices `dr` y `er` creadas, ahora vas a construir la **matriz Q_DEC**, que define **las tasas de cambio entre todos los estados posibles de rango geogr√°fico**.

``` r
Q_DEC := fnDECRateMatrix(dispersalRates=dr, extirpationRates=er)
Q_DEC
```

Esto hace lo siguiente:

-   Calcula autom√°ticamente las **64 combinaciones** de transiciones posibles entre los **8 estados** (con 3 √°reas, hay $2^3 = 8$ estados).

-   Llena la matriz `Q_DEC (8x8)` con tasas basadas en:

    -   La matriz de **dispersi√≥n** `dr`: para agregar √°reas al rango actual.

    -   La matriz de **extirpaci√≥n** `er`: para quitar √°reas del rango actual.

**Crear la matriz de probabilidades de transici√≥n:**

``` r
tp_DEC <- Q_DEC.getTransitionProbabilities(rate=0.2)
tp_DEC
```

Est√°s calculando la matriz de probabilidades de transici√≥n a lo largo de una rama del √°rbol de longitud 0.2 unidades de tiempo (por ejemplo, millones de a√±os).

**Veamos esta fila:**

| De `A` hacia...  | `A`   | `B`   | `C`   | `AB`  | `AC`  | `BC`  | `ABC` |
|------------------|-------|-------|-------|-------|-------|-------|-------|
| **Probabilidad** | 0.673 | 0.013 | 0.013 | 0.123 | 0.123 | 0.005 | 0.050 |

Esto responde: Si la especie est√° en `A`, qu√© tan probable es que termine en esos otros estados despu√©s de tiempo `t = 0.2`?

**En resumen**

| Comparaci√≥n          | `Q_DEC`                         | `tp_DEC`                                  |
|------------------|------------------------|-------------------------------|
| ¬øQu√© es?             | Matriz de tasas                 | Matriz de probabilidades                  |
| ¬øQu√© mide?           | Velocidad de cambio instant√°neo | Probabilidad de cambio tras cierto tiempo |
| ¬øDepende del tiempo? | ‚ùå No                           | ‚úÖ S√≠                                     |
| ¬øC√≥mo se calcula?    | Directamente de `dr` y `er`     | Usando exp‚Å°(Q‚ãÖt)exp(Q‚ãÖt)                   |
| ¬øPara qu√© se usa?    | Construir el modelo DEC         | Simular evoluci√≥n, inferir cambios        |

## Codificar eventos cladogen√©ticos en DEC

Cuando una especie se divide en dos nuevas especies (cladog√©nesis), su rango geogr√°fico tambi√©n se hereda de diferentes formas.

``` r
clado_event_types = [ "s", "a" ]
clado_event_probs <- simplex( 1, 1 )
P_DEC := fnDECCladoProbs(eventProbs=clado_event_probs,
                         eventTypes=clado_event_types,
                         numCharacters=n_areas)
```

1.  `clado_event_types = [ "s", "a" ]`

Define **qu√© tipos de eventos cladogen√©ticos** vas a permitir en el modelo.

-   `"s"` = **Subset sympatry**\
    Una especie hereda **todo el rango**, la otra solo **una parte** (un √°rea individual).\
    Ejemplo: `ABC ‚Üí (ABC, A)`

-   `"a"` = **Allopatry**\
    El rango se **divide** en dos partes complementarias.\
    Ejemplo: `ABC ‚Üí (AB, C)`

2.  `clado_event_probs <- simplex(1, 1)`

Esto crea un vector de **probabilidades normalizadas** (que suman 1).

üìå Como pusiste `1, 1`, est√°s diciendo:

-   `"s"` tendr√° **50% de probabilidad**

-   `"a"` tendr√° **50% de probabilidad**

üí° Si hubieras puesto `simplex(2, 1)`, la probabilidad ser√≠a:

-   `"s"` = 2/3

-   `"a"` = 1/3

3.  `P_DEC := fnDECCladoProbs(...)`

Esta funci√≥n genera la **matriz de probabilidades cladogen√©ticas**, combinando los tipos de eventos (`"s"`, `"a"`) con sus probabilidades (`50%-50%`), para todos los **estados posibles** del rango, de acuerdo al n√∫mero de √°reas (`n_areas`).

üìä **¬øQu√© incluye `P_DEC`?**

Una matriz **sparse** (dispersa) donde cada fila representa:

`(estado_ancestral ‚Üí sp_izquierda, sp_derecha) = probabilidad`

Ejemplo:

`(7 -> 7, 1) = 0.0833  # ABC ‚Üí (ABC, A)  ‚Üê subset sympatry`

`(7 -> 6, 1) = 0.0833  # ABC ‚Üí (AB, A)   ‚Üê allopatry`

`(7 -> 4, 3) = 0.0833  # ABC ‚Üí (A, BC)   ‚Üê allopatry`

Como usaste `"s"` y `"a"` con probabilidades iguales, **se reparten equitativamente** entre todos los eventos posibles v√°lidos bajo cada categor√≠a.

### ‚ö†Ô∏è **Aspectos clave a considerar**

-   El modelo DEC escala **exponencialmente** con el n√∫mero de √°reas:

    -   $3$ √°reas ‚Üí 8√ó8 anagen√©tico, $8^3 = 512$ eventos cladogen√©ticos

    -   $10$ √°reas ‚Üí $1024 √ó 1024$ (ya es muy pesado)

    -   $20$ √°reas ‚Üí ¬°matrices enormes! No viable computacionalmente.

## Espadas plateadas (Tribu Madiinae), un grupo end√©mico de Haw√°i.

-   Un grupo joven (\~5 millones de a√±os) y diverso de \~50 especies/subespecies

-   Se originaron en el continente (EE.UU. occidental), pero **radiaron en las islas hawaianas**

-   Son ideales para estudios porque:

    -   Las islas hawaianas se formaron de manera **cronol√≥gica** (K ‚Üí O ‚Üí M ‚Üí H)

    -   Hay buen registro de distribuci√≥n y filogenia.

    ![](https://revbayes.github.io/tutorials/biogeo/figures/fig_hawaii_areas.png){fig-align="center" width="550"}

üó∫Ô∏è **√Åreas geogr√°ficas usadas**

Para simplificar, el tutorial usa solo **4 √°reas** (con posibles combinaciones):

| C√≥digo binario | √Åreas           | Tama√±o | Estado (√≠ndice) |
|----------------|-----------------|--------|-----------------|
| `0000`         | Ninguna (‚àÖ)     | 0      | 0               |
| `1000`         | K (Kauai/Nihoa) | 1      | 1               |
| `0100`         | O (Oahu)        | 1      | 2               |
| `0010`         | M (Maui Nui)    | 1      | 3               |
| `0001`         | H (Hawai‚Äòi)     | 1      | 4               |
| `1100`         | KO              | 2      | 5               |
| `1010`         | KM              | 2      | 6               |
| `0110`         | OM              | 2      | 7               |
| `1001`         | KH              | 2      | 8               |
| `0101`         | OH              | 2      | 9               |
| `0011`         | MH              | 2      | 10              |
| `1110`         | KOM             | 3      | 11              |
| `1101`         | KOH             | 3      | 12              |
| `1011`         | KMH             | 3      | 13              |
| `0111`         | OMH             | 3      | 14              |
| `1111`         | KOMH            | 4      | 15              |

üìå Cada uno de estos estados representa un **rango posible** que puede ocupar una especie.

**Descargar los archivos necesarios**

<a href="../docs/u2_PatBio/silversword.tre" download>üì• Descargar √Årbol Filogen√©tico</a>

<a href="../docs/u2_PatBio/silversword.n4.range.nex" download>üì• Descargar matriz de datos con los rangos codificados de cada especie.</a>

**Crea un scrip para RevBayes y copia el siguiente codigo.**

``` r
# definir rutas de los archivos y ruta de salida
range_fn = "../data/silversword.n4.range.nex"
tree_fn  = "../data/silversword.tre"
out_fn   = "../output/DEC/simple"

# leer datos de presencia-ausencia (binarios 0/1) de los rangos geogr√°ficos
dat_range_01 = readDiscreteCharacterData(range_fn)

# convertir los rangos binarios en n√∫meros naturales (formato requerido por DEC)
dat_range_n = formatDiscreteCharacterData(dat_range_01, "DEC")

# comparar los caracteres (rangos) de dos taxones
dat_range_01[1]
dat_range_n[1]

# dimensiones de los datos (n√∫mero de √°reas y estados posibles)
n_areas  = dat_range_01.nchar()
n_states = floor(2^n_areas)

# obtener las descripciones de los estados convertidos
state_desc = dat_range_n.getStateDescriptions()

# escribir las descripciones de los estados en un archivo
state_desc_str = "state,range\n"
for (i in 1:state_desc.size())
{
    state_desc_str += (i-1) + "," + state_desc[i] + "\n"
}
write(state_desc_str, file=out_fn+".state_labels.txt")

# variables auxiliares (para guardar movimientos, monitores y n√∫mero de generaciones)
moves = VectorMoves()
monitors = VectorMonitors()
n_gen = 3000

##################################
# Modelos del √°rbol filogen√©tico #
##################################

# leer el √°rbol filogen√©tico
tree <- readTrees(tree_fn)[1]

##########################
# Modelos biogeogr√°ficos #
##########################

# multiplicador de la tasa de eventos biogeogr√°ficos
rate_bg ~ dnLoguniform(1E-4,1E2)
rate_bg.setValue(1E-2)
moves.append( mvScale(rate_bg, weight=4) )

# tasa de dispersi√≥n relativa
dispersal_rate <- 1.0

# construir la matriz de tasas de dispersi√≥n relativa
for (i in 1:n_areas) {
    for (j in 1:n_areas) {
        dr[i][j] <- dispersal_rate
    }
}

# luego, definir la tasa de extirpaci√≥n (extinci√≥n local) relativa por √°rea
log_sd <- 0.5
log_mean <- ln(1) - 0.5*log_sd^2
extirpation_rate ~ dnLognormal(mean=log_mean, sd=log_sd)
moves.append( mvScale(extirpation_rate, weight=2) )

# construir la matriz de tasas de extirpaci√≥n relativa
for (i in 1:n_areas) {
    for (j in 1:n_areas) {
        er[i][j] <- 0.0       
    }
    er[i][i] := extirpation_rate
}

# construir la matriz de tasas del modelo DEC (Q)
Q_DEC := fnDECRateMatrix(dispersalRates=dr,
                         extirpationRates=er)
                           
# construir la matriz de probabilidades de eventos cladogen√©ticos
clado_event_types <- [ "s", "a" ]
clado_event_probs <- simplex(1,1)
P_DEC := fnDECCladoProbs(eventProbs=clado_event_probs,
                         eventTypes=clado_event_types,
                         numCharacters=n_areas)

# modelo de cadena de Markov continua (CTMC) filogen√©tica con eventos cladogen√©ticos
m_bg ~ dnPhyloCTMCClado(tree=tree,
                           Q=Q_DEC,
                           cladoProbs=P_DEC,
                           branchRates=rate_bg,
                           type="NaturalNumbers",
                           nSites=1)
    
# fijar (clamp) los datos observados de rangos al modelo
m_bg.clamp(dat_range_n)

#############
# Monitores #
#############

monitors.append( mnScreen(printgen=100, rate_bg) )
monitors.append( mnModel(file=out_fn+".model.log", printgen=10) )
monitors.append( mnFile(tree, filename=out_fn+".tre", printgen=10) )
monitors.append( mnJointConditionalAncestralState(tree=tree,
                                                  ctmc=m_bg,
                                                  type="NaturalNumbers",
                                                  withTips=true,
                                                  withStartStates=true,
                                                  filename=out_fn+".states.log",
                                                  printgen=10) )
monitors.append( mnStochasticCharacterMap(ctmc=m_bg,
                                          filename=out_fn+".stoch.log",
                                          printgen=100) )

############
# An√°lisis #
############

# construir el objeto de an√°lisis del modelo a partir del grafo del modelo
mymodel = model(m_bg)

# crear el objeto de an√°lisis MCMC
mymcmc = mcmc(mymodel, monitors, moves)

# ejecutar el an√°lisis MCMC
mymcmc.run(n_gen)

# salir de revbayes
quit()
```

## **Procesar y visualizar los resultados**

Paso 1: Abre una nueva sesi√≥n de RevBayes y crea variables con los nombres de los archivos generados:

``` r
out_str = "../output/DEC/simple"
out_state_fn = out_str + ".states.log"   # Archivo con los estados ancestrales
out_tree_fn  = out_str + ".tre"          # √Årboles muestreados del posterior
out_mcc_fn   = out_str + ".mcc.tre"      # √Årbol de m√°xima credibilidad
```

Paso 2: Este paso **resume los √°rboles del posterior** (salvando la variabilidad) en **un solo √°rbol representativo**, √∫til para visualizar:

``` r
tree_trace = readTreeTrace(file=out_tree_fn, treetype="clock")  # Leer los √°rboles
tree_trace.setBurnin(0.25)          # Eliminar 25% como burn-in
n_burn = tree_trace.getBurnin()     # Guardar el n√∫mero de √°rboles descartados
```

üí° Aunque en este an√°lisis usaste un √°rbol fijo, este paso es **importante cuando el √°rbol se infiere** y var√≠a entre muestras (ej. posterior bayesiano completo).

``` r
mcc_tree = mccTree(tree_trace, file=out_mcc_fn)  # Crear y guardar el √°rbol MCC
```

Paso 3: Cargar los estados ancestrales reconstruidos

``` r
state_trace = readAncestralStateTrace(file=out_state_fn)
```

Este archivo contiene las **probabilidades posteriores de los estados en los nodos** del √°rbol.

Paso 4: Cargar los √°rboles anotados con estados ancestrales

‚ö†Ô∏è Aqu√≠ es importante usar `readAncestralStateTreeTrace` y **no** `readTreeTrace`, para mantener las anotaciones:

``` r
tree_trace = readAncestralStateTreeTrace(file=out_tree_fn, treetype="clock")
```

Paso 5: Generar el √°rbol con estados ancestrales

``` r
anc_tree = ancestralStateTree(
    tree=mcc_tree,
    ancestral_state_trace_vector=state_trace,
    tree_trace=tree_trace,
    include_start_states=true,
    file=out_str + ".ase.tre",
    burnin=n_burn,
    site=1
)
```

## Graficar en R con RevGadgets

-   **Abre un editor de texto** (ejemplo *VSCode* )

-   **Copia y pega** exactamente el siguiente contenido

-   **Guarda el archivo** dentro de la carpeta de resultados de tu an√°lisis DEC con el nombre \`range_colors.txt\`

``` r
range,color
"K","#7570b3"
"O","#e7298a"
"M","#66a61e"
"H","#e6ab02"
"KO","orchid"
"KM","firebrick3"
"OM","green"
"KH","cyan"
"OH","cadetblue3"
"MH","tomato"
"KOM","aquamarine2"
"KOH","#d95f02"
"KMH","royalblue"
"OMH","#666666"
"KOMH","darkviolet"
```

Este script define dos funciones auxiliares que se usan para **visualizar los resultados** de un an√°lisis de biogeograf√≠a (por ejemplo, con el modelo DEC), espec√≠ficamente para:

-   Mostrar los **estados ancestrales** como gr√°ficos de pastel (pie charts) sobre el √°rbol filogen√©tico.

-   A√±adir **informaci√≥n geol√≥gica**, como los tiempos de formaci√≥n de las islas hawaianas, sobre el eje temporal del √°rbol.

```{r}
# Cargar las bibliotecas necesarias
library(RevGadgets)
library(ggplot2)
library(ggtree)

# Funci√≥n para a√±adir l√≠neas verticales que marcan los tiempos de formaci√≥n de las islas
add_island_times = function(p, x_offset) {
    t = "dashed"
    p = p + geom_vline(xintercept=x_offset-5.05, color="#7570b3", linetype=t)
    p = p + geom_vline(xintercept=x_offset-5.15, color="#7570b3", linetype=t)
    p = p + geom_vline(xintercept=x_offset-2.2, color="#e7298a", linetype=t)
    p = p + geom_vline(xintercept=x_offset-3.7, color="#e7298a", linetype=t)
    p = p + geom_vline(xintercept=x_offset-1.3, color="#66a61e", linetype=t)
    p = p + geom_vline(xintercept=x_offset-1.8, color="#66a61e", linetype=t)
    p = p + geom_vline(xintercept=x_offset-0.3, color="#e6ab02", linetype=t)
    p = p + geom_vline(xintercept=x_offset-0.7, color="#e6ab02", linetype=t)
    return(p)
}

# Funci√≥n para construir etiquetas y colores de los estados ancestrales
make_states = function(label_fn, color_fn, fp="./") {

    # Leer la tabla de colores para cada rango geogr√°fico
    range_color_list = read.csv(color_fn, header=T, sep=",", colClasses="character")

    # Extraer los nombres de las √°reas individuales (por ejemplo: "K", "O", "M", "H")
    area_names = unlist(sapply(range_color_list$range, function(y) { if (nchar(y)==1) { return(y) } }))

    # Leer el archivo con las etiquetas de los estados codificados (binarios)
    state_descriptions = read.csv(label_fn, header=T, sep=",", colClasses="character")

    # Convertir los rangos codificados como "1010" en nombres como "KM"
    range_labels = sapply(state_descriptions$range[2:nrow(state_descriptions)],
        function(x) {
            present = as.vector(gregexpr(pattern="1", x)[[1]])
            paste( area_names[present], collapse="")
        })

    # Asignar un color a cada rango
    range_colors = range_color_list$color[ match(range_labels, range_color_list$range) ]

    # Generar listas con las etiquetas y los colores por estado
    idx = 1
    st_lbl = list()
    st_colors = c()
    for (j in 1:(nrow(state_descriptions)-1)) {
        st_lbl[[ as.character(j) ]] = range_labels[j]
        st_colors[j] = range_colors[j]
    }
    
    # A√±adir color para estados miscel√°neos o desconocidos
    st_colors[ length(st_colors)+1 ] = "lightgray"
    st_lbl[["misc."]] = "misc."
    
    # Devolver etiquetas y colores
    return( list(state_labels=st_lbl, state_colors=st_colors) )
}
```

Este script en R **genera una figura** que muestra un √°rbol filogen√©tico anotado con los **estados ancestrales geogr√°ficos**(rango de distribuci√≥n de cada nodo) inferidos con el modelo DEC en RevBayes. Utiliza gr√°ficos de pastel (pie charts) para representar **la incertidumbre en la reconstrucci√≥n** de rangos geogr√°ficos a lo largo del √°rbol evolutivo, y a√±ade **informaci√≥n temporal sobre la formaci√≥n de las islas hawaianas**.

```{r}
# nombres de archivo
# archivo de salida para la figura final en PDF
plot_fn = "../docs/u2_PatBio/output/DEC/simple.range.pdf" 
# √°rbol con estados ancestrales (generado en RevBayes)
tree_fn = "../docs/u2_PatBio/output/DEC/simple.ase.tre" 
# archivo con las etiquetas de los estados (rango binario ‚Üí etiquetas)
label_fn = "../docs/u2_PatBio/output/DEC/simple.state_labels.txt"
# archivo con los colores para cada rango
color_fn = "../docs/u2_PatBio/output/DEC/range_colors.txt"

# obtener etiquetas de estado y colores de estado
states = make_states(label_fn, color_fn)
state_labels = states$state_labels
state_colors = states$state_colors

# procesar los estados ancestrales
ase <- processAncStates(tree_fn,
                        # Estas etiquetas num√©ricas deben coincidir con
                        # las del archivo original de datos de entrada.
                        state_labels = state_labels)

# graficar los estados ancestrales como gr√°ficos de pastel (pie charts)
pp  <- plotAncStatesPie(t = ase,
                        # incluir los estados del nodo ra√≠z
                         include_start_states=T, 
                        # mostrar etiquetas de los estados
                         state_labels=state_labels,
                        # asignar los colores definidos
                         state_colors=state_colors, 
                        # tama√±o de las etiquetas en los extremos (tips)
                         tip_label_size=2.5,
                        # distancia de desplazamiento de las etiquetas
                         tip_label_offset=0.1,
                        # sin etiquetas num√©ricas en los nodos
                         node_label_size=0, 
                        # sin etiquetas en los hombros
                         shoulder_label_size=0, 
                        # mostrar leyenda de probabilidades posteriores
                         show_posterior_legend=T, 
                        # tama√±o de los c√≠rculos en los extremos (tips)
                         tip_pie_diameter=0.5, 
                         # tama√±o de los c√≠rculos en los nodos
                         node_pie_diameter=2.0,
                        # ajuste horizontal de los gr√°ficos de pastel
                         pie_nudge_x=0.03, 
                        # ajuste vertical de los gr√°ficos de pastel
                         pie_nudge_y=0.16, 
                         alpha=1) + # opacidad

  # mover la leyenda de estados
  theme(legend.position = c(0.1, 0.75))


# obtener las dimensiones del gr√°fico
 # obtener el valor m√°ximo del eje x (altura del √°rbol)
x_phy = max(pp$data$x)
 # espacio extra para las etiquetas de las hojas
x_label = 3.5 
 # edad inicial del eje (debe ser mayor a la ra√≠z del √°rbol)
x_start = 7  
# inicio del eje x
x0 = -(x_start - x_phy) 
# fin del eje x
x1 = x_phy + x_label 

# a√±adir eje cronol√≥gico
pp = pp + theme_tree2()
pp = pp + labs(x="Edad (Ma)")

# modificar l√≠mites del eje x
pp = pp + coord_cartesian(xlim=c(x0,x1), expand=TRUE)

# agregar marcas al eje y etiquetas de islas como eje secundario
island_axis = sec_axis(~ ., breaks=x_phy-c(5.1, 2.95, 1.55, 0.5), labels=c("+K","+O","+M","+H") )
x_breaks = seq(0,x_start,1) + x0
x_labels = rev(seq(0,x_start,1))
pp = pp + scale_x_continuous(breaks=x_breaks, labels=x_labels, sec.axis=island_axis)

# dibujar l√≠neas verticales que marcan los tiempos de formaci√≥n de islas
pp = add_island_times(pp, x_phy)

# configurar la posici√≥n de la leyenda
pp = pp + theme(legend.position="left")

# mostrar gr√°fico final
pp

# guardar el gr√°fico como archivo PDF
ggsave(file=plot_fn, plot=pp, device="pdf", height=7, width=10, useDingbats=F)
```
