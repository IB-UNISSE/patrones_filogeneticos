---
title: "Introducci√≥n al proceso de diversificaci√≥n"
format: html
execute:
  echo: true   # Muestra el c√≥digo
  warning: false  # Oculta advertencias
  fig-width: 12   # Ancho del gr√°fico
  fig-height: 8   # Altura del gr√°fico
---

# Presentaci√≥n: Introducci√≥n al proceso de diversificaci√≥n

[![](../images/u1_PatDiv/u1_PatDiv_1.png){fig-align="center" width="500"}](../docs/u1_PatDiv/IntroDiversificacioÃÅnPCB.pdf)

Haz clic en la imagen para ver el PDF de la presentaci√≥n

# Introducci√≥n a los m√©todos de diversificaci√≥n

En este m√≥dulo exploraremos dos enfoques para el an√°lisis de tasas de diversificaci√≥n:

-   **TreePar**: Implementado en R, este paquete permite detectar cambios en las tasas de especiaci√≥n y extinci√≥n en √°rboles filogen√©ticos a partir de datos temporales. Nos enfocaremos en la funci√≥n `bd.shifts.optim`, que optimiza modelos de nacimiento y muerte con cambios de tasa.

-   **RevBayes**: Utilizaremos el enfoque bayesiano para modelar la variaci√≥n en tasas de diversificaci√≥n a lo largo del tiempo, siguiendo el tutorial oficial [Simple Diversification Rate Model](https://revbayes.github.io/tutorials/divrate/simple.html).

# Instalaci√≥n de Paquetes en R

Para realizar los an√°lisis de diversificaci√≥n, es necesario instalar y cargar varios paquetes en R. Si no los tienes instalados, puedes ejecutar el siguiente c√≥digo:

``` r
# Instalar tidyverse si no est√° instalado
if (!requireNamespace("tidyverse", quietly = TRUE)) {
  install.packages("tidyverse", dependencies = TRUE)
}

# Instalar ape si no est√° instalado
if (!requireNamespace("ape", quietly = TRUE)) {
  install.packages("ape", dependencies = TRUE)
}

# Instalar BiocManager si no est√° instalado
if (!requireNamespace("BiocManager", quietly = TRUE)) {
  install.packages("BiocManager", dependencies = TRUE)
}

# Instalar ggtree y treeio si no est√°n instalados
if (!requireNamespace("ggtree", quietly = TRUE) || !requireNamespace("treeio", quietly = TRUE)) {
  BiocManager::install(c("ggtree", "treeio"))
}

# Instalar subplex si no est√° instalado
if (!requireNamespace("subplex", quietly = TRUE)) {
  install.packages("subplex", dependencies = TRUE)
}

# Instalar TreeSim si no est√° instalado
if (!requireNamespace("TreeSim", quietly = TRUE)) {
  install.packages("TreeSim", dependencies = TRUE)
}

# Instalar deSolve si no est√° instalado
if (!requireNamespace("deSolve", quietly = TRUE)) {
  install.packages("deSolve", dependencies = TRUE)
}

# Instalar phytools si no est√° instalado
if (!requireNamespace("phytools", quietly = TRUE)) {
  install.packages("phytools")
}

# Instalar DDD si no est√° instalado
if (!requireNamespace("DDD", quietly = TRUE)) {
  install.packages("DDD")
}

# Instalar RevGadgets si no est√° instalado
if (!requireNamespace("RevGadgets", quietly = TRUE)) {
  install.packages("RevGadgets")
}
```

# Instalaci√≥n de TreePar en R

El paquete **TreePar** no est√° disponible directamente desde CRAN, pero podemos instalarlo mediante dos m√©todos. Si no te funciona el primer m√©todo intenta el segundo:

## 1.- Mediante la liberia `remotes`

```{r}
# Instalar remotes si no est√° instalado
if (!requireNamespace("remotes", quietly = TRUE)) {
  install.packages("remotes")
}

# Instalar TreePar
remotes::install_github("tanja819/TreePar")
```

## 2.- Descargar el paquete TreePar

### Puedes descargar el paquete desde el siguiente enlace:

üì• [Descargar TreePar 3.3](http://cran.nexr.com/src/contrib/TreePar_3.3.tar.gz)

Guarda el archivo en una carpeta de tu elecci√≥n (por ejemplo, en `~/Descargas/` o `C:/Users/TuUsuario/Downloads/`).

------------------------------------------------------------------------

### Instalar TreePar desde el archivo descargado

Una vez que hayas descargado el archivo `TreePar_3.3.tar.gz`, abre R y ejecuta el siguiente c√≥digo para instalarlo:

``` r
# Definir la ruta donde se descarg√≥ el archivo
ruta_archivo <- "~/Descargas/TreePar_3.3.tar.gz"  # Cambia esta ruta seg√∫n tu sistema operativo

# Instalar el paquete desde el archivo .tar.gz
install.packages(ruta_archivo, repos = NULL, type = "source")
```

# Preparaci√≥n del √Årbol Filogen√©tico para An√°lisis

Para realizar los an√°lisis de tasas de diversificaci√≥n, primero debemos preparar el √°rbol filogen√©tico. En esta secci√≥n, cargaremos el √°rbol en R, filtraremos los taxones de inter√©s y generaremos un sub√°rbol optimizado.

------------------------------------------------------------------------

## Descarga del √Årbol Filogen√©tico

üì• Puedes descargar el archivo **NEXUS** con el √°rbol de estudio en el siguiente enlace:

<a href="../docs/u1_PatDiv/allSamples.tre" download>üì• Descargar √Årbol Filogen√©tico</a>

Guarda el archivo en la carpeta correspondiente y verifica su ubicaci√≥n antes de continuar.

------------------------------------------------------------------------

## Cargar y Visualizar el √Årbol en R

Ejecuta el siguiente c√≥digo en R para cargar el archivo y visualizar el √°rbol completo:

```{r}
# Cargar los paquetes necesarios
library(ape)
library(ggtree)
library(treeio)
library(tidyverse)

# Definir la ruta del archivo NEXUS
archivo_nexus <- "../docs/u1_PatDiv/allSamples.tre"  # Aseg√∫rate de cambiar esta ruta si es necesario

# Cargar el √°rbol
arbol <- read.nexus(archivo_nexus)

# Calcular el L√≠mite M√°ximo del Eje X
max_edge_length <- max(arbol$edge.length, na.rm = TRUE)

# Graficar el √°rbol
ggtree(arbol) +
  geom_tiplab(size = 3) +
  geom_text2(aes(subset = !isTip, label = node), hjust = -0.3) +  # Etiquetar nodos internos
  xlim(-0.5, max_edge_length * 1.4) +
  theme_tree2()

```

## Extraer los nombres de las terminales de un nodo espec√≠fico:

Utilizar la funci√≥n `getDescendants` para obtener los nombres de todas la terminales del nodo interno **61**:

```{r}
library(phytools)

nodo_interes <- 61  # Reemplaza este valor por el nodo de tu inter√©s

# Obtener los √≠ndices de los nodos descendientes
nodos_internos <- getDescendants(arbol, nodo_interes)

# Filtrar solo los √≠ndices que corresponden a las terminales (tips)
indices_tips <- nodos_internos[nodos_internos <= length(arbol$tip.label)]

# Obtener los nombres de las terminales
nombres_tips <- arbol$tip.label[indices_tips]

# Mostrar los nombres de las terminales
print(nombres_tips)

```

## Uso de `getMRCA` y `extract.clade` para extraer Sub√°rboles Filogen√©ticos

```{r}
# Obtener el nodo m√°s reciente en com√∫n del ingroup
mrca_ingroup <- getMRCA(arbol, nombres_tips)

# Extraer el sub√°rbol del ingroup
subarbol <- extract.clade(arbol, mrca_ingroup)

# Calcular la longitud m√°xima de las ramas del sub√°rbol
max_edge_length <- max(subarbol$edge.length, na.rm = TRUE)

# Graficar el sub√°rbol
ggtree(subarbol) +
  geom_tiplab(size = 3) +
  xlim(-0.5, max_edge_length * 2) +
  theme_tree2()
```

## Remover especies duplicadas

```{r}
# Separar los nombres de las especies (asumiendo el formato "ID_Especie")
species_info <- data.frame(
  tip_label = nombres_tips,
  species = str_extract(nombres_tips, "[A-Za-z]+_[A-Za-z]+(?:_[A-Za-z]+)?$")
)

# Eliminar las ssp _h y _p
# Seleccionar solo una muestra por especie
unique_species <- species_info %>%
  filter(!str_detect(species, "_[hp]$")) %>%
  group_by(species) %>% 
  slice(1) %>%  # Selecciona solo la primera aparici√≥n de cada especie
  ungroup()

# Extraer los nombres de los tips que queremos conservar
selected_tips <- unique_species$tip_label

# Remover duplicados
subarbol_final <- drop.tip(subarbol, setdiff(subarbol$tip.label, selected_tips))

ggtree(subarbol_final) + 
  geom_tiplab(size = 3) + 
  xlim(-0.5, max(subarbol_final$edge.length) * 2)  # Expande el espacio a la izquierda

```

## Guardar el √°rbol resultante en formato NEXUS

```{r}
write.nexus(subarbol_final, file="../docs/u1_PatDiv/subarbol_ingroup.nex")
```

# Estimar tasas de especiaci√≥n y extinci√≥n a lo largo del tiempo.

## Carga del √Årbol Filogen√©tico

```{r}
# Carga de paquetes
library(subplex)
library(TreeSim)
library(deSolve)
library(ape)       
library(TreePar)

# Cargar el √°rbol desde un archivo Nexus
tree <- read.nexus("../docs/u1_PatDiv/subarbol_ingroup.nex")

# Visualizar el √°rbol
ggtree(tree) + theme_tree()

```

## Obtenci√≥n de los Tiempos de Especiaci√≥n

Extraeremos y ordenaremos los tiempos de especiaci√≥n (tiempos de ramificaci√≥n) del √°rbol:

```{r}
# Obtener y ordenar los tiempos de especiaci√≥n
# La funci√≥n getx() extrae los tiempos de ramificaci√≥n del √°rbol.
times <- sort(getx(tree), decreasing = TRUE) # sort () rdena los tiempos en orden descendente.
times <- unname(times) # elimina los nombres de los elementos del vector para simplificar su manipulaci√≥n.
print(times)
```

## Configuraci√≥n de Par√°metros para el An√°lisis

Definiremos los par√°metros necesarios para el an√°lisis de cambios en las tasas de diversificaci√≥n:

```{r}
rho <- 22/26  # Proporci√≥n de especies muestreadas (22 de 26 especies)
grid <- 0.2   # Tama√±o de la grilla de b√∫squeda de cambios de tasa (en millones de a√±os)
start <- min(times)   # Tiempo inicial para la b√∫squeda de cambios de tasa
end <- max(times)     # Tiempo final para la b√∫squeda de cambios de tasa
```

## Ejecuci√≥n del An√°lisis con `bd.shifts.optim`

Utilizaremos la funci√≥n `bd.shifts.optim` para estimar las tasas de especiaci√≥n y extinci√≥n, as√≠ como los puntos en el tiempo donde ocurren cambios significativos en estas tasas:

```{r}
# Ejecutar el an√°lisis de cambios en las tasas de diversificaci√≥n
result_shifts <- bd.shifts.optim(times, rho, grid, start, end, yule=TRUE)

# Mostrar los resultados
result_shifts[[2]][[1]]
```

A continuaci√≥n se presentan los valores obtenidos en la estimaci√≥n de la tasa de diversificaci√≥n. Dado que el modelo **Yule** asume que no hay extinci√≥n, la tasa de extinci√≥n no est√° definida en este an√°lisis.

-   Valor de la funci√≥n de verosimilitud negativa: **70.02138**

-   Tasa de especiaci√≥n $\lambda$: **0.08913**

En este contexto:

Estos valores indican que la tasa de especiaci√≥n estimada ($\lambda$) es aproximadamente **0.08913**.

El valor de la funci√≥n de verosimilitud negativa (**70.02138**) proporciona una medida del ajuste del modelo a los datos, donde valores m√°s bajos generalmente indican un mejor ajuste.

# Estimaci√≥n simple de la tasa de diversificaci√≥n con RevBayes

## Crear un script de `RevBayes` en Visual Studio Code: `divrate.Rev`

## Cargar el archivo NEXUS

``` r
# Cargar la filogenia desde el archivo NEXUS
T <- readTrees("../docs/u1_PatDiv/subarbol_ingroup.nex")[1]

# Obtener la lista de taxones en la filogenia
taxa <- T.taxa()
```

## Inicializar los vectores de moves y monitors

``` r
# Inicializar un vector vac√≠o para los movimientos (moves)
moves = VectorMoves()

# Inicializar un vector vac√≠o para los monitores (monitors)
monitors = VectorMonitors()
```

![](/images/u1_PatDiv/u1_PatDiv_2.png){fig-align="center" width="450"}

Representaci√≥n del modelo gr√°fico para el proceso Yule (Pure-Birth) en RevBayes, donde la tasa de especiaci√≥n ($\lambda$) es tratada como una variable aleatoria extra√≠da de una distribuci√≥n uniforme.

## Especificar la tasa de especiaci√≥n ($\lambda$)

``` r
# Especificar la tasa de especiaci√≥n Œª con una distribuci√≥n uniforme
birth_rate ~ dnUniform(0, 100.0)
```

## Asignar un movimiento MCMC a la tasa de especiaci√≥n

``` r
# Agregar un movimiento MCMC para la tasa de especiaci√≥n
moves.append( mvScale(birth_rate, lambda=1.0, tune=true, weight=3.0) )
```

## Especificar la proporci√≥n de especies muestreadas **(**$\rho$)

``` r
# Obtener el n√∫mero de taxones en la filogenia
num_taxa <- T.ntips()

# Estimar la proporci√≥n de especies muestreadas
rho <- num_taxa / 26
```

## Obtener la edad de la ra√≠z

``` r
# Obtener la edad de la ra√≠z del √°rbol
root_time <- T.rootAge()
```

## Definir el modelo de tiempo de especiaci√≥n

El modelo Yule (pure-birth) en RevBayes se define con el **proceso de nacimiento y muerte (`dnBDP`)**, pero con la tasa de extinci√≥n (`mu`) fijada en **0**.

``` r
# Definir el modelo de diversificaci√≥n usando un proceso de nacimiento-muerte (BDP)
timetree ~ dnBDP(lambda=birth_rate, mu=0.0, rho=rho, rootAge=root_time, samplingStrategy="uniform", condition="survival", taxa=taxa)
```

**Explicaci√≥n**

-   `lambda = birth_rate` ‚Üí Tasa de especiaci√≥n es una variable aleatoria con `dnUniform(0, 100.0)`.

-   `mu = 0.0` ‚Üí Asumimos que no hay extinci√≥n (modelo Yule).

-   `rho = rho` ‚Üí Se ajusta seg√∫n el n√∫mero de especies muestreadas.

-   `rootAge = root_time` ‚Üí Condicionamos el modelo en la edad de la ra√≠z.

-   `samplingStrategy = "uniform"` ‚Üí Asumimos muestreo uniforme.

-   `condition = "survival"` ‚Üí Solo analizamos √°rboles que sobrevivieron hasta el presente.

## Fijar la filogenia observada

``` r
# Fijar la filogenia observada
timetree.clamp(T)
```

## Definir el modelo gr√°fico

``` r
# Crear el objeto de modelo
mymodel = model(birth_rate)
```

Esto crea un modelo gr√°fico dirigido ac√≠clico (DAG) donde birth_rate es el nodo principal, y RevBayes autom√°ticamente encuentra todos los otros nodos conectados.

## Especificar los Monitores

``` r
# Monitor para registrar los estados del modelo en un archivo de salida
monitors.append( mnModel(filename="output/diversification_Yule.log", printgen=10, separator=TAB) )

# Monitor para imprimir la tasa de especiaci√≥n en la pantalla cada 1000 generaciones
monitors.append( mnScreen(printgen=1000, birth_rate) )
```

**Explicaci√≥n**

-   **`mnModel`** guarda el registro de la ejecuci√≥n en `"output/diversification_Yule.log"`, escribiendo cada **10** generaciones.

-   **`mnScreen`** imprime la tasa de especiaci√≥n (`birth_rate`) en la consola cada **1000** generaciones.

## Configurar y ejecutar el MCMC

``` r
# Inicializar el MCMC con dos cadenas combinadas en un solo an√°lisis
mymcmc = mcmc(mymodel, monitors, moves, nruns=2, combine="mixed")

# Ejecutar el MCMC por 50,000 generaciones, ajustando los movimientos cada 200 generaciones
mymcmc.run(generations=50000, tuningInterval=200)
```

**Explicaci√≥n**

-   **`nruns=2`** ‚Üí Corre dos cadenas independientes.

-   **`combine="mixed"`** ‚Üí Combina las cadenas en un solo conjunto de muestras.

-   **`generations=50000`** ‚Üí Ejecuta la simulaci√≥n por 50,000 generaciones.

-   **`tuningInterval=200`** ‚Üí Ajusta los movimientos cada 200 generaciones para mejorar la eficiencia del muestreo.

## Cargar los resultados en RevGadgets

Despu√©s de correr el MCMC en RevBayes, usar **RevGadgets** en **R** para analizar la distribuci√≥n posterior:

```{r}
# Cargar librer√≠as necesarias
library(RevGadgets)
library(ggplot2)

# Leer los datos del MCMC
mcmc_trace <- readTrace("../docs/u1_PatDiv/output/diversification_Yule.log")

# Visualizar la distribuci√≥n posterior de birth_rate
plotTrace(mcmc_trace, vars="birth_rate")
```

## Calcular la media y el intervalo de HPD (Highest Posterior Density)

```{r}
# Calcular la media posterior y el HPD del 95%
summary_stats <- summarizeTrace(mcmc_trace, vars="birth_rate")
print(summary_stats)
```

## Comparar la distribuci√≥n previa y posterior

```{r}
library(RevGadgets)
library(ggplot2)

# Leer los datos del MCMC combinando las dos cadenas
posterior_trace <- readTrace(c("../docs/u1_PatDiv/output/diversification_Yule_run_1.log", "../docs/u1_PatDiv/output/diversification_Yule_run_2.log"))

# Extraer el primer conjunto de muestras (lista de data frames)
yule_posterior <- posterior_trace[[1]]

# Simular 10,000 valores de la distribuci√≥n previa
yule_prior <- data.frame(birth_rate = runif(10000, min=0, max=100))

# Agregar la columna de la distribuci√≥n previa en el posterior
yule_posterior$birth_rate_prior <- sample(yule_prior$birth_rate, size = nrow(yule_posterior), replace = TRUE)

# Graficar la comparaci√≥n
plotTrace(list(yule_posterior), vars = c("birth_rate", "birth_rate_prior"))[[1]] +
  theme(legend.position = c(0.80, 0.80),  # Ubicaci√≥n de la leyenda
        legend.text = element_text(size =20),  # Tama√±o del texto de la leyenda
        legend.title = element_text(size = 22)) +  # Tama√±o del t√≠tulo de la leyenda
  xlim(0, 1)  # Ajusta el l√≠mite seg√∫n los valores observados
```
